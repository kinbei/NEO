本文主要讲述如何使用 `network` 模块提供的接口编写`通讯协议`文件  

## 协议文件格式
(1) 协议文件必须返回一个 `table`, 返回的 `table` 必须包含 `create_request()` 和 `create_response()` 两个函数       
(2) `create_request()` 和 `create_response()` 必须分别返回一个 `table`, 返回的 `table` 必须包含 `serial()` 和 `unserial()` 两个函数       
(3) `serial()`函数用于处理协议的序列化; `unserial()`函数用于处理协议的反序列化;       
(4) `create_response()` 返回的 `table` 中必须包含一个 `retcode` 表示错误码     

一个最简单的协议文件格式如下所示:     
```lua
local network = require("network")

local function request_serial(self, buffer)
end

local function request_unserial(self, buffer)
end

local function response_serial(self, buffer)
	network.writenumber(buffer, self.retcode)
end

local function response_unserial(self, buffer)
	self.retcode = network.readnumber(buffer)
end

local protocol = {}
function protocol.create_request()
	local request = {}

	request.serial = request_serial
	request.unserial = request_unserial
	return request
end

function protocol.create_response()
	local response = {}
	response.retcode = 0x00000000

	response.serial = response_serial
	response.unserial = response_unserial
	return response
end

return protocol
```

## 协议序列化接口     
通用规则: 
1. `network.read` 前缀的函数通常用于 `unserial()` 函数中
2. `network.write` 前缀的函数通常用于 `serial()` 函数中

(1) `network.readnumber()` 和 `network.writenumber()` 用于序列化 和 反序列化 一个数字       
```lua
network.writenumber(buffer, player_id)
local player_id = network.readnumber(buffer)
```

(2) `network.readstring()` 和 `network.writestring()` 用于序列化 和 反序列化 一个字符串     
```lua
network.writestring(buffer, nickname)
local nickname = network.readstring(buffer)
```
